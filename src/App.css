/*
==========================================================
                    REACT HOOKS CHEAT SHEET
==========================================================

1ï¸âƒ£ useState â€“ â€œState Keeperâ€
----------------------------------------------------------
- Purpose: Store values that can change and trigger re-render.
- Think: A box where you keep a value, and when you update it, React redraws the component.
- Syntax:
  const [value, setValue] = useState(initialValue);

- Example:
  const [count, setCount] = useState(0);
  <button onClick={() => setCount(count + 1)}>Add</button>
  
- Key: Use it for anything that changes in the UI like input values, toggles, counters.

----------------------------------------------------------
2ï¸âƒ£ useEffect â€“ â€œSide Effect Handlerâ€
----------------------------------------------------------
- Purpose: Run code AFTER render. Useful for fetching data, subscriptions, or interacting with browser APIs.
- Think: A reminder note that says: â€œAfter render, do this.â€
- Syntax:
  useEffect(() => {
    // code runs after render
  }, [dependencies]);

- Dependencies:
  [] â†’ run once (component did mount)
  [x] â†’ run whenever x changes
  no array â†’ runs after every render

- Example:
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  }, [count]);

----------------------------------------------------------
3ï¸âƒ£ useRef â€“ â€œPersistent Referenceâ€
----------------------------------------------------------
- Purpose: Keep a reference to a DOM element or any value that doesnâ€™t trigger re-render.
- Think: A sticky note; you can check or update it anytime, but React ignores it for rendering.
- Syntax:
  const ref = useRef(initialValue);

- Example (focus input):
  const inputRef = useRef(null);
  <input ref={inputRef} />
  inputRef.current.focus(); // focuses input

- Also used to store timers, previous values, or mutable variables that persist across renders.

----------------------------------------------------------
4ï¸âƒ£ useMemo â€“ â€œPerformance Optimizerâ€
----------------------------------------------------------
- Purpose: Memorize a computed value to avoid expensive recalculation on every render.
- Think: Solve a math problem once, write it down, reuse the answer.
- Syntax:
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

- Example:
  const expensiveResult = useMemo(() => {
    return heavyCalculation(count);
  }, [count]);

- Key: Only use for performance optimization; it wonâ€™t change your UI logic.

----------------------------------------------------------
ğŸ’¡ Quick Metaphors:
- useState â†’ A box that triggers UI updates
- useEffect â†’ A post-it note â€œdo this after renderâ€
- useRef â†’ A sticky note that React ignores for re-render
- useMemo â†’ Notebook with precomputed answers

==========================================================
*/

/*
====================================================================
ğŸ“’ NOTES APP â€“ FULL DEEP EXPLANATION (BEGINNER â†’ CONFIDENT)
====================================================================

ğŸ‘‰ This file explains EVERYTHING that happens in your notes app.
ğŸ‘‰ Read slowly. Come back again and again.
ğŸ‘‰ This explanation matches your exact code.

====================================================================
ğŸ§  BIG PICTURE â€“ HOW THE APP WORKS
====================================================================

This is a NOTES APP with:
- Create note
- Read note
- Update note
- Delete note
- Save notes even after refresh
- Search notes
- Sort notes

This app is made of 4 MAIN PARTS:

1ï¸âƒ£ App.jsx        â†’ Brain of the app (state, routes, storage)
2ï¸âƒ£ Home.jsx       â†’ Shows all notes (list page)
3ï¸âƒ£ NewNotes.jsx   â†’ Create / Edit / Delete notes
4ï¸âƒ£ PromptClamp.jsxâ†’ Cut long text (See More / Less)

App.jsx owns the data.
Other pages USE that data.

====================================================================
1ï¸âƒ£ App.jsx â€“ ROOT / BRAIN OF THE APP
====================================================================

ğŸ“Œ This file decides:
- Where data lives
- Which page is shown
- When Nav shows
- Saving notes to localStorage

------------------------------------------------
ğŸ”¹ useState for notes
------------------------------------------------

const [notes, setNotes] = useState(() => {
  const savedNotes = localStorage.getItem("notes");
  return savedNotes ? JSON.parse(savedNotes) : [];
});

WHAT IS HAPPENING LINE BY LINE?

- useState stores notes array
- We pass a FUNCTION to useState (important!)
- That function runs ONLY ONCE (first render)

Why function?
ğŸ‘‰ So localStorage is NOT read again and again

localStorage.getItem("notes")
- Reads saved notes from browser storage
- Returns STRING or null

JSON.parse(savedNotes)
- Converts string â†’ JavaScript array

If nothing saved â†’ empty array []

------------------------------------------------
ğŸ”¹ useEffect for localStorage
------------------------------------------------

useEffect(() => {
  localStorage.setItem("notes", JSON.stringify(notes));
}, [notes]);

WHAT THIS MEANS:

- Whenever `notes` changes
- Save latest notes into localStorage

JSON.stringify(notes)
- Converts JS array â†’ string
(localStorage only stores strings)

[notes] (dependency array)
- Effect runs ONLY when notes changes

------------------------------------------------
ğŸ”¹ URL logic for Nav
------------------------------------------------

let url = window.location.href.split("/").pop();

- Gets last part of URL
- Example:
  http://localhost:5173/NewNotes?id=123
  â†’ NewNotes?id=123

if (url.includes("?")) {
  url = url.split("?")[0];
}

- Removes query params
- Final result â†’ "NewNotes"

allowedUrls = ["", "NewNotes"]

{allowedUrls.includes(url) && <Nav />}

- Shows Nav ONLY on:
  âœ” Home
  âœ” NewNotes
- Hides Nav on NotFound

------------------------------------------------
ğŸ”¹ Routes
------------------------------------------------

<Routes>
  <Route index element={<Home notes={notes} setNotes={setNotes} />} />
  <Route path="/NewNotes" element={<NewNotes notes={notes} setNotes={setNotes} />} />
  <Route path="*" element={<NotFound />} />
</Routes>

IMPORTANT IDEA:
- App owns notes
- App passes notes & setNotes to children
- This is called "lifting state up"

====================================================================
2ï¸âƒ£ Home.jsx â€“ NOTES LIST PAGE
====================================================================

ğŸ“Œ Purpose:
- Show all notes
- Search notes
- Sort notes
- Click note â†’ edit page

------------------------------------------------
ğŸ”¹ useState in Home
------------------------------------------------

const [searchFilter, setSearchFilter] = useState("");
const [sortBy, setSortBy] = useState("recent");

- searchFilter â†’ text user types
- sortBy â†’ selected sorting option

------------------------------------------------
ğŸ”¹ Filtering notes
------------------------------------------------

const filteredNotes = notes.filter((note) => {
  return (
    note.title.toLowerCase().includes(searchFilter.toLowerCase()) ||
    note.body.toLowerCase().includes(searchFilter.toLowerCase())
  );
});

STEP BY STEP:
- filter() loops through notes
- toLowerCase() â†’ case-insensitive
- includes() â†’ checks matching text
- If title OR body matches â†’ keep note

------------------------------------------------
ğŸ”¹ Sorting notes
------------------------------------------------

const sortedNotes = [...filteredNotes].sort((a, b) => {

WHY [...filteredNotes] ?
- sort() CHANGES original array
- NEVER mutate state directly
- Spread creates a COPY

if (sortBy === "alphabet") {
  return a.title.toLowerCase().localeCompare(b.title.toLowerCase());
}

- localeCompare compares strings
- Returns:
  - negative â†’ a before b
  - positive â†’ b before a

if (sortBy === "lastEdited") {
  return b.updatedAt - a.updatedAt;
}

- Bigger timestamp first

return b.createdAt - a.createdAt;
- Default â†’ newest first

------------------------------------------------
ğŸ”¹ Rendering notes
------------------------------------------------

sortedNotes.map((note) => (
  <div
    key={note.id}
    onClick={() => navigate(`/NewNotes?id=${note.id}`)}
  >

- map() converts data â†’ UI
- key helps React track items
- Clicking navigates with note id
- id travels via URL

====================================================================
3ï¸âƒ£ NewNotes.jsx â€“ CREATE / EDIT / DELETE
====================================================================

ğŸ“Œ Purpose:
- Same page for:
  âœ” Create new note
  âœ” Edit existing note
  âœ” Delete note

------------------------------------------------
ğŸ”¹ Local state
------------------------------------------------

const [notesTitle, setNotesTitle] = useState("");
const [notesBody, setNotesBody] = useState("");

- Controlled inputs
- UI always synced with state

------------------------------------------------
ğŸ”¹ Reading ID from URL
------------------------------------------------

const [searchParams] = useSearchParams();
const id = searchParams.get("id");

- Reads ?id=123
- Returns string or null

const editingId = id ? Number(id) : null;

- Convert to number
- null means "new note"

------------------------------------------------
ğŸ”¹ Find editing note
------------------------------------------------

const editingNote = notes.find((note) => note.id === editingId);

- find() returns ONE note
- If not found â†’ undefined

------------------------------------------------
ğŸ”¹ useEffect to fill inputs
------------------------------------------------

useEffect(() => {
  if (editingNote) {
    setNotesTitle(editingNote.title);
    setNotesBody(editingNote.body);
  } else {
    setNotesTitle("");
    setNotesBody("");
  }
}, [editingNote]);

WHY?
- When user clicks note
- editingNote changes
- Inputs auto-fill
- If new note â†’ inputs cleared

------------------------------------------------
ğŸ”¹ Add Note
------------------------------------------------

handleAdd():
- Validate inputs
- Create note object
- Add using [...notes, newNote]
- Navigate home

IMPORTANT:
- Never push()
- Always create new array

------------------------------------------------
ğŸ”¹ Edit Note
------------------------------------------------

notes.map((note) =>
  note.id === editingId
    ? { ...note, title, body, updatedAt }
    : note
)

- map loops all notes
- Updates only matching note
- Keeps others unchanged

------------------------------------------------
ğŸ”¹ Remove Note
------------------------------------------------

notes.filter(note => note.id !== editingId)

- filter removes matching note
- Returns new array

------------------------------------------------
ğŸ”¹ Conditional UI
------------------------------------------------

editingId === null
- Show "Add Note"

else
- Show "Update" + "Remove"

This is CONDITIONAL RENDERING.

====================================================================
4ï¸âƒ£ PromptClamp.jsx â€“ SEE MORE / LESS
====================================================================

ğŸ“Œ Purpose:
- Cut long text
- Expand on click

------------------------------------------------
ğŸ”¹ State
------------------------------------------------

isExpanded â†’ show full text or not
shouldCut â†’ text longer than 100 chars?

------------------------------------------------
ğŸ”¹ useEffect
------------------------------------------------

useEffect(() => {
  setShouldCut(text.length > 100);
}, [text]);

- Runs when text changes
- Decides if "See More" needed

------------------------------------------------
ğŸ”¹ stopPropagation
------------------------------------------------

e.stopPropagation();

- Prevents click bubbling
- Stops opening note when clicking "See More"

====================================================================
ğŸ§  CORE REACT CONCEPTS YOU LEARNED
====================================================================

âœ” useState â†’ store UI data
âœ” useEffect â†’ sync side effects
âœ” Props â†’ pass data
âœ” Immutability â†’ map/filter/spread
âœ” Routing â†’ pages & navigation
âœ” Query params â†’ editing logic
âœ” Conditional rendering â†’ smart UI
âœ” localStorage â†’ persistence

====================================================================
ğŸš€ FINAL NOTE
====================================================================

This is NOT beginner React anymore.
You built a REAL production-style app.

If you understand THIS,
you can build:
- Todo apps
- Blogs
- Dashboards
- CRUD apps

Keep revisiting this file.
This is your React foundation.

====================================================================
END
====================================================================
*/
